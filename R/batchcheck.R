#' Function for running a set of scripts
#' Use with caution!
#' If you run this script, all submitted R scripts will be executed automatically.
#' Be sure that you trust these scripts - they could severely harm your computer.
#' @param dirname Character, the directory that contains the scripts for analysing.
#' @param assignment An assignment, prepared with \link{prepareAssignment}.
#' @param pattern The pattern that the R scripts adhere to. By default all files ending in .R are found.
#' @param rec Whether or not to find files recursively, i.e. in subdirectories too.
#' @param overridewarnings Whether or not to show a warning before running the function.
#' @returns A list containing detailed output on each of the R scripts in the submitted directory. The output can be passed to \link{analyseBatch}, \link{extractScripts} or \link{extractFeedback} for further processing.
#' @import crayon
#' @export
runBatch <- function(dirname,assignment,pattern=".*\\.R$",rec=FALSE,overridewarning=FALSE){

  allFiles <- list.files(dirname,pattern=pattern,recursive = rec,full.names = FALSE)
  cat("The following files have been found:\n")
  cat(allFiles,sep="\n")
  cat(red$bold("\n\nIf you proceed - all these R files will be executed, with potentially harmful consequences to your computer. Are you certain you want to proceed? Proceeding is entirely at your own risk!\n\n"))
  inp <- "waiting"
  iter <- 1
  while(!inp %in% c('yes','no') & iter < 5){
  if(iter>1){
    cat(red("Inut not recognized. Please type either yes or no."))
  }
  inp <- readline("Do you wish to run all these R files? (yes/no)")
  if(overridewarning){
    inp <- "yes"
  }
  iter <- iter + 1
  }
  if(!inp %in% c('yes','no')){
    stop("Function arborted -- no valid yes or no answer detected.")
  }

  if(inp =='no'){
    stop("Function aborted by user.")
    return(1)
  }

  myout <- lapply(allFiles, FUN = function(x){
    out <- list()
    fb <- capture.output(out <- runEval(file.path(dirname,x),assignment$trackfuns,assignment$ref,assignment$net,verbose = TRUE,netcount = TRUE))
    out$feedback <- fb
    out$net$node <- rownames(out$net)
    out
    })

  myout
}

#' Visualise the batch run
#'
#' Draws the decision net with thickness of edges corresponding to the number of scripts that went through that edge.
#' Final nodes (END nodes) display the number of submissions in them.
#' @param batchobj An object generated by \link{batchRun}
#' @param draw A character indicating whether one wants to make a static or an interactive igraph plot
#' @param maxwidth The maximum width of the edges
#' @param ... Additional arguments that are being passed to igraphs plotting functions.
#' @import tidyr
#' @import dplyr
#' @export
analyseBatch <- function(batchobj,draw=c("static","interactive"),maxwidth=5,...){

  nets <- lapply(batchobj, FUN = function(x){
    tmp <- x$net
    tmp$file <- x$obj$filename
    tmp
  })

  nets.df <- do.call(rbind,nets)

  overview <- nets.df %>% pivot_longer(nT:nF) %>% select(file,node,goT,goF,doT,doF,name,value) %>% mutate(go=ifelse(name=='nT',goT,goF),message=ifelse(name=='nT',doT,doF))
  forDrawing <- overview %>% group_by(node,go,name,message) %>% summarize(num=sum(value,na.rm=TRUE))
  forDrawing$fullname <- paste(ifelse(forDrawing$name=="nT","True\n","False\n"),forDrawing$message)

  forDrawing$go[forDrawing$go=="END"] <- paste0("END",1:sum(forDrawing$go=="END"))
  allnodes <- unique(c(forDrawing$node,forDrawing$go))
  relations <- data.frame(from=forDrawing$node,to=forDrawing$go,label=forDrawing$fullname,arrow.mode=2*as.numeric(!grepl("^END",forDrawing$go)),width=0.1+maxwidth*(forDrawing$num)/max(forDrawing$num))

  vertexlabels <- allnodes#paste(allnodes,df$cond[match(allnodes,df$node)],sep="\n")
  numpervertex <- forDrawing$num[match(vertexlabels,forDrawing$go)]
  vertexlabels[grepl(pattern = "^END",allnodes)] <- numpervertex[grepl(pattern = "^END",allnodes)]

  g <- graph_from_data_frame(relations,vertices=data.frame(id=allnodes,label=vertexlabels,shape=c("none","circle")[1+as.numeric(grepl("^END",allnodes))],color="grey"))
  E(g)$color <- c('#99000099','#00990099')[1+as.numeric(forDrawing$name=="nT")]
  color2 <- c('#990000','#009900')[1+as.numeric(forDrawing$name=="nT")]
  if(draw=="interactive"){
    tkplot(g,edge.arrow.size=0.5,edge.arrow.width=1,edge.label.color=color2,vertex.label.color="black",...)
  }else if(draw=="static"){
    plot(g,edge.arrow.size=0.5,edge.arrow.width=1,edge.label.color=color2,vertex.label.color="black",...)
  }
}
# myout <- runBatch("C:/Documents and Settings/Koen/Downloads/Assignment exercise Lecture 6 Download 04 December 2025 447 PM",assignment=MyAssignment,rec=TRUE)

#' Function for getting all scripts from specific nodes
#'
#' Extract script names from a given node.
#' @param batchobj An object generated by \link{batchRun}
#' @param node A character indicating the node that one wants to obtain the scripts from
#' @param target (optional) If one wants to extract scripts that have moved between two specific nodes, also include a target node.
#' @export
extractScripts <- function(batchobj,node,target){

  nets <- lapply(batchobj, FUN = function(x){
    tmp <- x$net
    tmp$file <- x$obj$filename
    tmp
  })

  nets.df <- do.call(rbind,nets)

  overview <- nets.df %>% pivot_longer(nT:nF) %>% select(file,node,goT,goF,doT,doF,name,value) %>% mutate(go=ifelse(name=='nT',goT,goF),message=ifelse(name=='nT',doT,doF))
  if(missing(target)){
    overview$file[overview$go==node & overview$value==1]
  }else{
    overview$file[overview$node==node & overview$value==1 & overview$target==go]
  }
}

#' Obtain feedback
#' Function for turning a batch check object into a dataframe that contains the feedback for each student.
#' @param batchobj An object generated by \link{batchRun}
#' @returns A dataframe with two columns. 1. The filenames of the R scripts, 2. The output that was generated by VeRitas
#' @export
extractFeedback <- function(batchobj){
  do.call(rbind,lapply(batchobj, FUN = function(x) data.frame(filename=x$obj$filename,feedback=paste(x$feedback[x$feedback!=""],collapse="\n\n"))))
}
